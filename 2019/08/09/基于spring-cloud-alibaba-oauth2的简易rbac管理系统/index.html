<!DOCTYPE html>
<html lang="zh-cn">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统"/>
<meta name="twitter:description" content=""/>
<meta name="twitter:site" content="@"/>



  	<meta property="og:title" content="基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统 &middot; 元昊的博客" />
  	<meta property="og:site_name" content="元昊的博客" />
  	<meta property="og:url" content="https://ncjdjyh.github.io/2019/08/09/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" />

    
        
            <meta property="og:image" content="/images/1.jpg"/>
        
    

    
    <meta property="og:description" content="" />
  	<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2019-08-09T16:25:35&#43;08:00" />

    
    <meta property="article:tag" content="daily" />
    
    

    <title>基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统 &middot; 元昊的博客</title>

    
    <meta name="description" content="背景 这篇文章主要用来记录笔本人学习和搭建该系统的问题和收获。阅读这篇文章需要对OAuth2协议和Spring Security有一定的了解。关于OAuth2，其实是一个鉴权与授权的规范（如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步理解OAuth 2.0 - 阮一峰）这里我简单列举一个场景说明授权" />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://ncjdjyh.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://ncjdjyh.github.io/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="https://ncjdjyh.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://ncjdjyh.github.io/css/nav.css" />

    

    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/atom-one-light.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
        
        <script>hljs.initHighlightingOnLoad();</script>
    

    
      
          <link href="https://ncjdjyh.github.io/index.xml" rel="alternate" type="application/rss+xml" title="元昊的博客" />
      
      
    
    <meta name="generator" content="Hugo 0.56.3" />

    <link rel="canonical" href="https://ncjdjyh.github.io/2019/08/09/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" />

    
      
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name":  null ,
        "logo": "https://ncjdjyh.github.io/images/check-circle.png"
    },
    "author": {
        "@type": "Person",
        "name":  null ,
        
        "image": {
            "@type": "ImageObject",
            "url": "https://ncjdjyh.github.io/images/check-circle.png",
            "width": 250,
            "height": 250
        }, 
        
        "url":  null ,
        "sameAs": [
            
            
             
             
             
             
             
            
        ],
        "description": "Every man dies, not every man really lives."
        
    },
    "headline": "基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统",
    "name": "基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统",
    "wordCount":  579 ,
    "timeRequired": "PT3M",
    "inLanguage": {
      "@type": "Language",
      "alternateName": "en"
    },
    "url": "https://ncjdjyh.github.io/2019/08/09/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",
    "datePublished": "2019-08-09T16:25Z",
    "dateModified": "2019-08-09T16:25Z",
    
    "keywords": "daily",
    "description": "",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ncjdjyh.github.io/2019/08/09/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"
    }
}
    </script>
    


    

    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://ncjdjyh.github.io/">首页</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://ncjdjyh.github.io/tags/daily">日常</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://ncjdjyh.github.io/tags/series">重新造轮子</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://ncjdjyh.github.io/tags/music">音乐</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://ncjdjyh.github.io/about">关于我</a>
            </li>
        
        
    </ul>

    
    <a class="subscribe-button icon-feed" href="https://ncjdjyh.github.io/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">



<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
      <a class="blog-logo" href="https://ncjdjyh.github.io/"><img src="https://ncjdjyh.github.io/images/check-circle.png" alt="Home" /></a>
  
  
      <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">基于Spring Cloud Alibaba OAuth2的简易RBAC管理系统</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2019-08-09T16:25:35&#43;08:00">
            Aug 9, 2019
          </time>
        
         
          <span class="post-tag small"><a href="https://ncjdjyh.github.io//tags/daily/">#daily</a></span>
         
        </section>
    </header>

    <section class="post-content">
      

<h3 id="背景">背景</h3>

<p>这篇文章主要用来记录笔本人学习和搭建该系统的问题和收获。阅读这篇文章需要对OAuth2协议和Spring Security有一定的了解。关于OAuth2，其实是一个鉴权与授权的规范（如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 - 阮一峰</a>）这里我简单列举一个场景说明授权码模式(authorization code)的使用。比如现在我想使用QQ登录bilibili。</p>

<p><a href="https://imgchr.com/i/eLiwNj"><img src="https://s2.ax1x.com/2019/08/10/eLiwNj.md.png" alt="eLiwNj.md.png" /></a></p>

<p><a href="https://imgchr.com/i/eLi04s"><img src="https://s2.ax1x.com/2019/08/10/eLi04s.md.png" alt="eLi04s.md.png" /></a></p>

<p>OAuth 2.0的运行流程如下图：</p>

<p><a href="https://imgchr.com/i/eLFCKf"><img src="https://s2.ax1x.com/2019/08/10/eLFCKf.png" alt="eLFCKf.png" /></a></p>

<ul>
<li><strong>Client</strong>: 第三方应用程序，在这里其实就是bilibili</li>
<li><strong>User Agent</strong>：这里指我的Chrome浏览器</li>
<li><strong>Resource Owner</strong>：资源所有者，这里指的是我自己</li>
<li><strong>Authorization server</strong>：认证服务器，这里指QQ的认证服务器</li>
<li><strong>Resource Server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。</li>
</ul>

<p>在这个例子中：腾讯当然不希望你在登录B站的过程中暴露了QQ的账号和密码，OAuth就是为了解决这样的问题而出现的，它设置了一个授权层，客户端不能直接登录服务提供者，只能登录授权层，通过获取授权码(即图中的AccessToken)的方式来访问资源服务器的资源。</p>

<p>有很多安全框架(Shiro Spring Security)都可以实现OAuth2规范，本文使用Spring Security对它进行实现。</p>

<h3 id="架构图">架构图</h3>

<p><img src="https://s2.ax1x.com/2019/08/06/ehrvRK.jpg" alt="ehrvRK.jpg" /></p>

<p>客户端的请求是通过网关(Gateway Service)以http协议来传输信息，网关调用一个统一的授权服务器(Auth Service)验证用户信息并返回一个用来访问资源的授权码(AccessToken)，在鉴权服务的搭建上采用了OAuth2认证的密码授权模式而没有使用OAuth中最为严密的授权码模式，原因除了简单以外还因为这是一个只存在内部调用的内部系统。在该系统中除了网关服务和授权服务，其他的所有服务都可以看成是资源服务(Resource Server)，他们都受到Spring Security的保护且通过授权码来访问资源，服务间使用Fegin来相互调用Fegin使用http访问其他内部服务,除了http通信方式外，在分布式系统中各个服务间也经常使用RPC通信方式,阿里的Dubbo和Google的gRPC都是这样的网络通信框架。笔者基于Netty实现了一个很简单的RPC工具：<a href="https://github.com/ncjdjyh/yh-rpc">源码</a>。</p>

<h3 id="服务配置中心">服务配置中心</h3>

<p>Spring Cloud Alibaba使用nacos作为配置中心，所以首先需要搭建配置中心服务器，具体的方法可以参考官方</p>

<p><a href="https://nacos.io/zh-cn/docs/quick-start.html">文档</a>这是成功后的效果。<a href="https://imgchr.com/i/eLx2PP"><img src="https://s2.ax1x.com/2019/08/10/eLx2PP.md.png" alt="eLx2PP.md.png" /></a></p>

<p>然后当一个服务启动的时候将其注册到配置中心中，我的配置如下</p>

<pre><code>spring.application.name=gateway-service
spring.cloud.nacos.config.file-extension=yaml
spring.cloud.nacos.config.server-addr=localhost:8848
spring.cloud.nacos.config.group=DEFAULT_GROUP
</code></pre>

<h3 id="网关-gateway-service">网关(gateway-service)</h3>

<p>网关使用Spring Cloud Gateway实现服务路由。使用lb://服务名配置路由表可以轻松实现基于Ribbion的负载均衡，更多配置可以参考<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html">这里</a>，我的配置如下：</p>

<pre><code>spring:
  main:
    web-application-type: none
  application: 
    name: gateway-service
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.1.164:3306/oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=GMT
    username: root
    password: root
    type: com.alibaba.druid.pool.DruidDataSource
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.1.164:8848
    gateway:
      discovery:
        locator:
          enabled: true
      routes:
        - id: common-service
          uri: lb://common-service
          predicates:
            - Path=/common/**
          filters:
            - StripPrefix=1

        - id: api-service
          uri: lb://api-service
          predicates:
            - Path=/api/**
          filters:
            - StripPrefix=1

        - id: auth-service
          uri: lb://auth-service
          predicates:
            - Path=/auth/**
          filters:
            - StripPrefix=1

server:
  port: 5099

logging:
  config: classpath:logback-spring.xml
</code></pre>

<p>网关中添加了一个全局过滤器用来清洗请求头，后面会说到这样做的目的</p>

<pre><code>public class RequestGlobalFilter implements GlobalFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest().mutate()
                .headers(httpHeaders -&gt; httpHeaders.remove(DefaultSecurityConstants.FROM))
                .build();

        return chain.filter(exchange.mutate()
                .request(request)
                .build());
    }
}
</code></pre>

<h3 id="rbac">RBAC</h3>

<p>RBAC（Role-Based Access Control）是权限模型的一种，一个用户可以有多个角色，一个角色可以有多个权限：
<a href="https://imgchr.com/i/eLj7Lj"><img src="https://s2.ax1x.com/2019/08/10/eLj7Lj.png" alt="eLj7Lj.png" /></a>
为了实现用户-角色-权限三者的关系，Mysql建立如下表结构：
<a href="https://imgchr.com/i/eLj2dI"><img src="https://s2.ax1x.com/2019/08/10/eLj2dI.png" alt="eLj2dI.png" /></a></p>

<h3 id="授权服务器">授权服务器</h3>

<p>接下来开始搭建授权授权服务，客户端信息和token的存储我都是采用Mysql来存储的。</p>

<pre><code>@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {
    @Autowired
    DataSource dataSource;
    @Autowired
    PasswordEncoder passwordEncoder;
    @Autowired
    private AuthenticationManager authenticationManager;

    @Bean
    public TokenStore tokenStore() {
    	// 存放 token
        return new JdbcTokenStore(dataSource);
    }

    @Bean
    public ClientDetailsService jdbcClientDetails() {
    	// 存放客户端信息
        return new JdbcClientDetailsService(dataSource);
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.tokenStore(tokenStore())
                .authenticationManager(authenticationManager);
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.withClientDetails(jdbcClientDetails());
    }

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) {
        security.tokenKeyAccess(&quot;permitAll()&quot;)
                .checkTokenAccess(&quot;permitAll()&quot;)
                .allowFormAuthenticationForClients();
    }
}
</code></pre>

<h3 id="配置spring-security">配置Spring Security</h3>

<p>Spring Security中的内容和配置十分繁杂，但作为Spring体系中的一个重要组成部分，也遵循Spring约定大于配置的哲学，内部有很多的自动配置，在使用的时候通常只需要重写最需要的那一部分。下面给出我的配置:</p>

<pre><code>@Configuration
@EnableWebSecurity
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {
   ....
    @Override
    @SneakyThrows
    protected void configure(HttpSecurity http) {
        http
                .authorizeRequests()
                // 通过所有oauth的请求，也就是获取认证授权相关的
                .antMatchers(&quot;/actuator/**&quot;, &quot;/oauth/**&quot;)
                .permitAll()
                .anyRequest().authenticated()
                .and().csrf().disable();
    }
    ....
}
</code></pre>

<p>实现UserDetailsService</p>

<pre><code>@Component
public class DefaultUserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private AuthService authService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    	// 根据用户名获取用户
        TbUser user = authService.getUserByUserName(username, DefaultSecurityConstants.FROM_IN);
        List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList();
        if (user != null) {
        	// 获取用户所有权限
            List&lt;TbPermission&gt; userPermission = authService.getAllUserAuth(user.getId(), DefaultSecurityConstants.FROM_IN);
            userPermission.forEach(p -&gt; {
                if (p != null &amp;&amp; p.getUrl() != null) {
                    GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(p.getUrl());
                    grantedAuthorities.add(grantedAuthority);
                }
            });
        }
        // 装配成Spring Security中的User
        return new User(user.getUsername(), user.getPassword(), grantedAuthorities);
    }
}
</code></pre>

<p>值得一提的是，在这里我们需要用到用户的信息，有两种思路，一是直接将用户的实体的及数据访问放在授权服务器中，二是使用远程调用的方式来获取用户的相关信息。这两种方法应该说没有绝对的好坏，主要看业务需求。我采用的是第二种方式。这样带来了一个问题，在发起远程请求的时候我并没有获取用户资源的权限，因为现在我仍然是一个未授权的用户。怎样解决这个问题呢。我的方法是在请求头中添加一个参数标识这是一个内部请求，资源服务器如果看到这个标识就放弃权限的认证。</p>

<pre><code>@FeignClient(value = &quot;common-service&quot;)
public interface AuthService {
    /**
     * @param userName 用户名称
     * @param from 内部调用标识
     */
    @GetMapping(value = &quot;/user/getUserByAccount/{account}&quot;)
    TbUser getUserByUserName(@PathVariable(&quot;account&quot;) String userName, @RequestHeader(DefaultSecurityConstants.FROM) String from);
	....
}
</code></pre>

<p>这也是为什么在网关中为什么需要清洗请求头的原因：防止客户端在请求的时候伪造内部请求。</p>

<p>将UserDetailsService放到AuthenticationManagerBuilder中</p>

<pre><code>@Configuration
@EnableWebSecurity
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {
    ....
    
    @Override
    @SneakyThrows
    protected void configure(AuthenticationManagerBuilder auth) {
    	// 装配UserDetailsService
        auth.userDetailsService(userDetailsService());
    }
    
	....
}
</code></pre>

<p>这差不多是实现Spring Security安全特性的最小化配置了，关于Spring Security的更多配置和为什么要这样配置我这里就不赘述了，网上已经有很多教程了，有兴趣的小伙伴可以去看看。</p>

<h3 id="资源服务器">资源服务器</h3>

<p>资源服务器需要调用授权服务器来验证用户权限，配置如下</p>

<pre><code>....

security:
  oauth2:
    resource:
      token-info-uri: http://localhost:6000/oauth/check_token
....
</code></pre>

<p>资源服务器使用Spring Security的Web Security Expressions来实现RBAC权限控制：</p>

<pre><code>@Slf4j
public class DefaultResourceServerConfigurerAdapter extends ResourceServerConfigurerAdapter {
	....
	@Override
	@SneakyThrows
	public void configure(HttpSecurity http) {
		http.
                csrf().disable()
				.authorizeRequests()
				.antMatchers(&quot;/actuator/**&quot;).permitAll()
				.anyRequest()
				.access(&quot;@rbacService.hasPermission(request, authentication)&quot;);
	}
	...
}
</code></pre>

<pre><code>public class RbacService {

    private AntPathMatcher antPathMatcher = new AntPathMatcher();

    public boolean hasPermission(HttpServletRequest request, Authentication auth) {
    	// 如果是内部调用或者有权限返回成功
        return validateInnerProviderCall(request) || validateAuth(auth.getAuthorities(), request.getRequestURI());
    }

    private boolean validateInnerProviderCall(HttpServletRequest request) {
        String header = request.getHeader(DefaultSecurityConstants.FROM);
        return StrUtil.equals(DefaultSecurityConstants.FROM_IN, header);
    }

    private boolean validateAuth(Collection&lt;? extends GrantedAuthority&gt; collection, String url) {
        AtomicBoolean isPass = new AtomicBoolean(false);

        collection.stream()
                .map(GrantedAuthority::getAuthority)
                .forEach(e -&gt; {
                    if (antPathMatcher.match(e, url)) {
                       isPass.set(true);
                    }
                });

        return isPass.get();
    }
}
</code></pre>

<p>当然，在一个系统中资源服务器的数量常常会有很多个，我们当然不希望每次重复写这一段代码，采用Spring的IOC特性可以在服务启动的时候将它们自动的装载进去：</p>

<p><strong>定义一个注解标识资源服务器</strong></p>

<pre><code>@Documented
@Inherited
@EnableResourceServer
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@EnableGlobalMethodSecurity(prePostEnabled = true)
@Import({SecurityBeanDefinitionRegistrar.class})
public @interface EnableInnerResourceServer {

}
</code></pre>

<p><strong>编写自动注入类</strong></p>

<pre><code>@Slf4j
public class SecurityBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
	/**
	 * 根据注解值动态注入资源服务器的相关属性
	 * @param metadata 注解信息
	 * @param registry 注册器
	 */
	@Override
	public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
		GenericBeanDefinition resourceServerBean = new GenericBeanDefinition();
		GenericBeanDefinition rbacServiceBean = new GenericBeanDefinition();
		resourceServerBean.setBeanClass(DefaultResourceServerConfigurerAdapter.class);
		rbacServiceBean.setBeanClass(RbacService.class);
		registry.registerBeanDefinition(DefaultSecurityConstants.RESOURCE_SERVER_CONFIGURER, resourceServerBean);
		registry.registerBeanDefinition(DefaultSecurityConstants.RBAC_SERVICE_BEAN_NAME, rbacServiceBean);
	}
}
</code></pre>

<p><strong>让注解生效</strong></p>

<pre><code>@SpringCloudApplication
@MapperScan(&quot;com.ncjdjyh.series.oauth2.common.mapper&quot;)
@EnableInnerResourceServer
public class CommonApplication {
    public static void main(String[] args) {
        SpringApplication.run(CommonApplication.class);
    }
}
</code></pre>

<h3 id="参考资料">参考资料</h3>

<p><a href="http://blog.didispace.com/spring-security-oauth2-xjf-1/">从零开始的Spring Security Oauth2</a></p>

<p><a href="https://shuwoom.com/?p=3041">RBAC权限分析、设计与实现</a></p>

<p><a href="https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/">Spring Security Reference</a></p>

<p><a href="https://www.funtl.com/zh/guide/Spring-Security-oAuth2.html">李卫民Spring Security OAuth2</a></p>

<p><a href="https://github.com/ncjdjyh/spring-cloud-alibaba-oauth2-rbac">github地址</a></p>

    </section>


  <footer class="post-footer">


    








<figure class="author-image">
    <a class="img" href="https://ncjdjyh.github.io/" style="background-image: url(/images/check-circle.png)"><span class="hidden">ncjdjyh's Picture</span></a>
</figure>


<section class="author">
  <h4><a href="https://ncjdjyh.github.io/">ncjdjyh</a></h4>
  
  <p>Every man dies, not every man really lives.</p>
  
  <div class="author-meta">
    <span class="author-location icon-location">Nanjin, China</span>
    
  </div>
</section>




    
<section class="share">
  <h4>Share this post</h4>
  <a class="icon-twitter" style="font-size: 1.4em" href="https://twitter.com/share?text=%e5%9f%ba%e4%ba%8eSpring%20Cloud%20Alibaba%20OAuth2%e7%9a%84%e7%ae%80%e6%98%93RBAC%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f&nbsp;-&nbsp;%e5%85%83%e6%98%8a%e7%9a%84%e5%8d%9a%e5%ae%a2&amp;url=https%3a%2f%2fncjdjyh.github.io%2f2019%2f08%2f09%2f%25E5%259F%25BA%25E4%25BA%258Espring-cloud-alibaba-oauth2%25E7%259A%2584%25E7%25AE%2580%25E6%2598%2593rbac%25E7%25AE%25A1%25E7%2590%2586%25E7%25B3%25BB%25E7%25BB%259F%2f"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
      <span class="hidden">Twitter</span>
  </a>
  <a class="icon-facebook" style="font-size: 1.4em" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fncjdjyh.github.io%2f2019%2f08%2f09%2f%25E5%259F%25BA%25E4%25BA%258Espring-cloud-alibaba-oauth2%25E7%259A%2584%25E7%25AE%2580%25E6%2598%2593rbac%25E7%25AE%25A1%25E7%2590%2586%25E7%25B3%25BB%25E7%25BB%259F%2f"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
      <span class="hidden">Facebook</span>
  </a>
  <a class="icon-pinterest" style="font-size: 1.4em" href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fncjdjyh.github.io%2f2019%2f08%2f09%2f%25E5%259F%25BA%25E4%25BA%258Espring-cloud-alibaba-oauth2%25E7%259A%2584%25E7%25AE%2580%25E6%2598%2593rbac%25E7%25AE%25A1%25E7%2590%2586%25E7%25B3%25BB%25E7%25BB%259F%2f&amp;description=%e5%9f%ba%e4%ba%8eSpring%20Cloud%20Alibaba%20OAuth2%e7%9a%84%e7%ae%80%e6%98%93RBAC%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f"
      onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
      <span class="hidden">Pinterest</span>
  </a>
  <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=https%3a%2f%2fncjdjyh.github.io%2f2019%2f08%2f09%2f%25E5%259F%25BA%25E4%25BA%258Espring-cloud-alibaba-oauth2%25E7%259A%2584%25E7%25AE%2580%25E6%2598%2593rbac%25E7%25AE%25A1%25E7%2590%2586%25E7%25B3%25BB%25E7%25BB%259F%2f"
     onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
      <span class="hidden">Google+</span>
  </a>
</section>



    

<div id="disqus_thread"></div>
<script>




var disqus_config = function () {
this.page.url = "https:\/\/ncjdjyh.github.io\/2019\/08\/09\/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F\/";  
this.page.identifier = "https:\/\/ncjdjyh.github.io\/2019\/08\/09\/%E5%9F%BA%E4%BA%8Espring-cloud-alibaba-oauth2%E7%9A%84%E7%AE%80%E6%98%93rbac%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F\/"; 
};

(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://ncjdjyh.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>








  </footer>
</article>

</main>


  <aside class="read-next">
  
  
      <a class="read-next-story prev" style="no-cover" href="https://ncjdjyh.github.io/2018/10/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
          <section class="post">
              <h2>我的第一个编程语言</h2>
          </section>
      </a>
  
</aside>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">元昊的博客</a> All rights reserved - 2019</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://ncjdjyh.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://ncjdjyh.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://ncjdjyh.github.io/js/index.js"></script>
    
</body>
</html>

